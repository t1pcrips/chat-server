// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i chat-server/internal/service.FakeTx -o fake_tx_minimock.go -n FakeTxMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// FakeTxMock implements mm_service.FakeTx
type FakeTxMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func(ctx context.Context) (t1 pgx.Tx, err error)
	funcBeginOrigin    string
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mFakeTxMockBegin

	funcCommit          func(ctx context.Context) (err error)
	funcCommitOrigin    string
	inspectFuncCommit   func(ctx context.Context)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mFakeTxMockCommit

	funcConn          func() (cp1 *pgx.Conn)
	funcConnOrigin    string
	inspectFuncConn   func()
	afterConnCounter  uint64
	beforeConnCounter uint64
	ConnMock          mFakeTxMockConn

	funcCopyFrom          func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error)
	funcCopyFromOrigin    string
	inspectFuncCopyFrom   func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource)
	afterCopyFromCounter  uint64
	beforeCopyFromCounter uint64
	CopyFromMock          mFakeTxMockCopyFrom

	funcExec          func(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error)
	funcExecOrigin    string
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...any)
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mFakeTxMockExec

	funcLargeObjects          func() (l1 pgx.LargeObjects)
	funcLargeObjectsOrigin    string
	inspectFuncLargeObjects   func()
	afterLargeObjectsCounter  uint64
	beforeLargeObjectsCounter uint64
	LargeObjectsMock          mFakeTxMockLargeObjects

	funcPrepare          func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)
	funcPrepareOrigin    string
	inspectFuncPrepare   func(ctx context.Context, name string, sql string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mFakeTxMockPrepare

	funcQuery          func(ctx context.Context, sql string, args ...any) (r1 pgx.Rows, err error)
	funcQueryOrigin    string
	inspectFuncQuery   func(ctx context.Context, sql string, args ...any)
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mFakeTxMockQuery

	funcQueryRow          func(ctx context.Context, sql string, args ...any) (r1 pgx.Row)
	funcQueryRowOrigin    string
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...any)
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mFakeTxMockQueryRow

	funcRollback          func(ctx context.Context) (err error)
	funcRollbackOrigin    string
	inspectFuncRollback   func(ctx context.Context)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mFakeTxMockRollback

	funcSendBatch          func(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults)
	funcSendBatchOrigin    string
	inspectFuncSendBatch   func(ctx context.Context, b *pgx.Batch)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mFakeTxMockSendBatch
}

// NewFakeTxMock returns a mock for mm_service.FakeTx
func NewFakeTxMock(t minimock.Tester) *FakeTxMock {
	m := &FakeTxMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mFakeTxMockBegin{mock: m}
	m.BeginMock.callArgs = []*FakeTxMockBeginParams{}

	m.CommitMock = mFakeTxMockCommit{mock: m}
	m.CommitMock.callArgs = []*FakeTxMockCommitParams{}

	m.ConnMock = mFakeTxMockConn{mock: m}

	m.CopyFromMock = mFakeTxMockCopyFrom{mock: m}
	m.CopyFromMock.callArgs = []*FakeTxMockCopyFromParams{}

	m.ExecMock = mFakeTxMockExec{mock: m}
	m.ExecMock.callArgs = []*FakeTxMockExecParams{}

	m.LargeObjectsMock = mFakeTxMockLargeObjects{mock: m}

	m.PrepareMock = mFakeTxMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*FakeTxMockPrepareParams{}

	m.QueryMock = mFakeTxMockQuery{mock: m}
	m.QueryMock.callArgs = []*FakeTxMockQueryParams{}

	m.QueryRowMock = mFakeTxMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*FakeTxMockQueryRowParams{}

	m.RollbackMock = mFakeTxMockRollback{mock: m}
	m.RollbackMock.callArgs = []*FakeTxMockRollbackParams{}

	m.SendBatchMock = mFakeTxMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*FakeTxMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFakeTxMockBegin struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockBeginExpectation
	expectations       []*FakeTxMockBeginExpectation

	callArgs []*FakeTxMockBeginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockBeginExpectation specifies expectation struct of the FakeTx.Begin
type FakeTxMockBeginExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockBeginParams
	paramPtrs          *FakeTxMockBeginParamPtrs
	expectationOrigins FakeTxMockBeginExpectationOrigins
	results            *FakeTxMockBeginResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockBeginParams contains parameters of the FakeTx.Begin
type FakeTxMockBeginParams struct {
	ctx context.Context
}

// FakeTxMockBeginParamPtrs contains pointers to parameters of the FakeTx.Begin
type FakeTxMockBeginParamPtrs struct {
	ctx *context.Context
}

// FakeTxMockBeginResults contains results of the FakeTx.Begin
type FakeTxMockBeginResults struct {
	t1  pgx.Tx
	err error
}

// FakeTxMockBeginOrigins contains origins of expectations of the FakeTx.Begin
type FakeTxMockBeginExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mFakeTxMockBegin) Optional() *mFakeTxMockBegin {
	mmBegin.optional = true
	return mmBegin
}

// Expect sets up expected params for FakeTx.Begin
func (mmBegin *mFakeTxMockBegin) Expect(ctx context.Context) *mFakeTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &FakeTxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.paramPtrs != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by ExpectParams functions")
	}

	mmBegin.defaultExpectation.params = &FakeTxMockBeginParams{ctx}
	mmBegin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.Begin
func (mmBegin *mFakeTxMockBegin) ExpectCtxParam1(ctx context.Context) *mFakeTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &FakeTxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.params != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Expect")
	}

	if mmBegin.defaultExpectation.paramPtrs == nil {
		mmBegin.defaultExpectation.paramPtrs = &FakeTxMockBeginParamPtrs{}
	}
	mmBegin.defaultExpectation.paramPtrs.ctx = &ctx
	mmBegin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Begin
func (mmBegin *mFakeTxMockBegin) Inspect(f func(ctx context.Context)) *mFakeTxMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by FakeTx.Begin
func (mmBegin *mFakeTxMockBegin) Return(t1 pgx.Tx, err error) *FakeTxMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &FakeTxMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &FakeTxMockBeginResults{t1, err}
	mmBegin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// Set uses given function f to mock the FakeTx.Begin method
func (mmBegin *mFakeTxMockBegin) Set(f func(ctx context.Context) (t1 pgx.Tx, err error)) *FakeTxMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the FakeTx.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the FakeTx.Begin method")
	}

	mmBegin.mock.funcBegin = f
	mmBegin.mock.funcBeginOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// When sets expectation for the FakeTx.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mFakeTxMockBegin) When(ctx context.Context) *FakeTxMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Set")
	}

	expectation := &FakeTxMockBeginExpectation{
		mock:               mmBegin.mock,
		params:             &FakeTxMockBeginParams{ctx},
		expectationOrigins: FakeTxMockBeginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Begin return parameters for the expectation previously defined by the When method
func (e *FakeTxMockBeginExpectation) Then(t1 pgx.Tx, err error) *FakeTxMock {
	e.results = &FakeTxMockBeginResults{t1, err}
	return e.mock
}

// Times sets number of times FakeTx.Begin should be invoked
func (mmBegin *mFakeTxMockBegin) Times(n uint64) *mFakeTxMockBegin {
	if n == 0 {
		mmBegin.mock.t.Fatalf("Times of FakeTxMock.Begin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBegin.expectedInvocations, n)
	mmBegin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBegin
}

func (mmBegin *mFakeTxMockBegin) invocationsDone() bool {
	if len(mmBegin.expectations) == 0 && mmBegin.defaultExpectation == nil && mmBegin.mock.funcBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBegin.mock.afterBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Begin implements mm_service.FakeTx
func (mmBegin *FakeTxMock) Begin(ctx context.Context) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	mmBegin.t.Helper()

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := FakeTxMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, &mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_want_ptrs := mmBegin.BeginMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockBeginParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBegin.t.Errorf("FakeTxMock.Begin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBegin.BeginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("FakeTxMock.Begin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBegin.BeginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the FakeTxMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to FakeTxMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished FakeTxMock.Begin invocations
func (mmBegin *FakeTxMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of FakeTxMock.Begin invocations
func (mmBegin *FakeTxMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mFakeTxMockBegin) Calls() []*FakeTxMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*FakeTxMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockBeginDone() bool {
	if m.BeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginMock.invocationsDone()
}

// MinimockBeginInspect logs each unmet expectation
func (m *FakeTxMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Begin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBeginCounter := mm_atomic.LoadUint64(&m.afterBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && afterBeginCounter < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.Begin at\n%s", m.BeginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Begin at\n%s with params: %#v", m.BeginMock.defaultExpectation.expectationOrigins.origin, *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && afterBeginCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Begin at\n%s", m.funcBeginOrigin)
	}

	if !m.BeginMock.invocationsDone() && afterBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.Begin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginMock.expectedInvocations), m.BeginMock.expectedInvocationsOrigin, afterBeginCounter)
	}
}

type mFakeTxMockCommit struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockCommitExpectation
	expectations       []*FakeTxMockCommitExpectation

	callArgs []*FakeTxMockCommitParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockCommitExpectation specifies expectation struct of the FakeTx.Commit
type FakeTxMockCommitExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockCommitParams
	paramPtrs          *FakeTxMockCommitParamPtrs
	expectationOrigins FakeTxMockCommitExpectationOrigins
	results            *FakeTxMockCommitResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockCommitParams contains parameters of the FakeTx.Commit
type FakeTxMockCommitParams struct {
	ctx context.Context
}

// FakeTxMockCommitParamPtrs contains pointers to parameters of the FakeTx.Commit
type FakeTxMockCommitParamPtrs struct {
	ctx *context.Context
}

// FakeTxMockCommitResults contains results of the FakeTx.Commit
type FakeTxMockCommitResults struct {
	err error
}

// FakeTxMockCommitOrigins contains origins of expectations of the FakeTx.Commit
type FakeTxMockCommitExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommit *mFakeTxMockCommit) Optional() *mFakeTxMockCommit {
	mmCommit.optional = true
	return mmCommit
}

// Expect sets up expected params for FakeTx.Commit
func (mmCommit *mFakeTxMockCommit) Expect(ctx context.Context) *mFakeTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &FakeTxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.paramPtrs != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by ExpectParams functions")
	}

	mmCommit.defaultExpectation.params = &FakeTxMockCommitParams{ctx}
	mmCommit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommit.expectations {
		if minimock.Equal(e.params, mmCommit.defaultExpectation.params) {
			mmCommit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommit.defaultExpectation.params)
		}
	}

	return mmCommit
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.Commit
func (mmCommit *mFakeTxMockCommit) ExpectCtxParam1(ctx context.Context) *mFakeTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &FakeTxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.params != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Expect")
	}

	if mmCommit.defaultExpectation.paramPtrs == nil {
		mmCommit.defaultExpectation.paramPtrs = &FakeTxMockCommitParamPtrs{}
	}
	mmCommit.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommit.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Commit
func (mmCommit *mFakeTxMockCommit) Inspect(f func(ctx context.Context)) *mFakeTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by FakeTx.Commit
func (mmCommit *mFakeTxMockCommit) Return(err error) *FakeTxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &FakeTxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &FakeTxMockCommitResults{err}
	mmCommit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// Set uses given function f to mock the FakeTx.Commit method
func (mmCommit *mFakeTxMockCommit) Set(f func(ctx context.Context) (err error)) *FakeTxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the FakeTx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the FakeTx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	mmCommit.mock.funcCommitOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// When sets expectation for the FakeTx.Commit which will trigger the result defined by the following
// Then helper
func (mmCommit *mFakeTxMockCommit) When(ctx context.Context) *FakeTxMockCommitExpectation {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Set")
	}

	expectation := &FakeTxMockCommitExpectation{
		mock:               mmCommit.mock,
		params:             &FakeTxMockCommitParams{ctx},
		expectationOrigins: FakeTxMockCommitExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommit.expectations = append(mmCommit.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Commit return parameters for the expectation previously defined by the When method
func (e *FakeTxMockCommitExpectation) Then(err error) *FakeTxMock {
	e.results = &FakeTxMockCommitResults{err}
	return e.mock
}

// Times sets number of times FakeTx.Commit should be invoked
func (mmCommit *mFakeTxMockCommit) Times(n uint64) *mFakeTxMockCommit {
	if n == 0 {
		mmCommit.mock.t.Fatalf("Times of FakeTxMock.Commit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommit.expectedInvocations, n)
	mmCommit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommit
}

func (mmCommit *mFakeTxMockCommit) invocationsDone() bool {
	if len(mmCommit.expectations) == 0 && mmCommit.defaultExpectation == nil && mmCommit.mock.funcCommit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommit.mock.afterCommitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Commit implements mm_service.FakeTx
func (mmCommit *FakeTxMock) Commit(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	mmCommit.t.Helper()

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit(ctx)
	}

	mm_params := FakeTxMockCommitParams{ctx}

	// Record call args
	mmCommit.CommitMock.mutex.Lock()
	mmCommit.CommitMock.callArgs = append(mmCommit.CommitMock.callArgs, &mm_params)
	mmCommit.CommitMock.mutex.Unlock()

	for _, e := range mmCommit.CommitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)
		mm_want := mmCommit.CommitMock.defaultExpectation.params
		mm_want_ptrs := mmCommit.CommitMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockCommitParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommit.t.Errorf("FakeTxMock.Commit got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommit.CommitMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommit.t.Errorf("FakeTxMock.Commit got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommit.CommitMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the FakeTxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit(ctx)
	}
	mmCommit.t.Fatalf("Unexpected call to FakeTxMock.Commit. %v", ctx)
	return
}

// CommitAfterCounter returns a count of finished FakeTxMock.Commit invocations
func (mmCommit *FakeTxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of FakeTxMock.Commit invocations
func (mmCommit *FakeTxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Commit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommit *mFakeTxMockCommit) Calls() []*FakeTxMockCommitParams {
	mmCommit.mutex.RLock()

	argCopy := make([]*FakeTxMockCommitParams, len(mmCommit.callArgs))
	copy(argCopy, mmCommit.callArgs)

	mmCommit.mutex.RUnlock()

	return argCopy
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockCommitDone() bool {
	if m.CommitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitMock.invocationsDone()
}

// MinimockCommitInspect logs each unmet expectation
func (m *FakeTxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Commit at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommitCounter := mm_atomic.LoadUint64(&m.afterCommitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && afterCommitCounter < 1 {
		if m.CommitMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.Commit at\n%s", m.CommitMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Commit at\n%s with params: %#v", m.CommitMock.defaultExpectation.expectationOrigins.origin, *m.CommitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && afterCommitCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Commit at\n%s", m.funcCommitOrigin)
	}

	if !m.CommitMock.invocationsDone() && afterCommitCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.Commit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommitMock.expectedInvocations), m.CommitMock.expectedInvocationsOrigin, afterCommitCounter)
	}
}

type mFakeTxMockConn struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockConnExpectation
	expectations       []*FakeTxMockConnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockConnExpectation specifies expectation struct of the FakeTx.Conn
type FakeTxMockConnExpectation struct {
	mock *FakeTxMock

	results      *FakeTxMockConnResults
	returnOrigin string
	Counter      uint64
}

// FakeTxMockConnResults contains results of the FakeTx.Conn
type FakeTxMockConnResults struct {
	cp1 *pgx.Conn
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConn *mFakeTxMockConn) Optional() *mFakeTxMockConn {
	mmConn.optional = true
	return mmConn
}

// Expect sets up expected params for FakeTx.Conn
func (mmConn *mFakeTxMockConn) Expect() *mFakeTxMockConn {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("FakeTxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &FakeTxMockConnExpectation{}
	}

	return mmConn
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Conn
func (mmConn *mFakeTxMockConn) Inspect(f func()) *mFakeTxMockConn {
	if mmConn.mock.inspectFuncConn != nil {
		mmConn.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Conn")
	}

	mmConn.mock.inspectFuncConn = f

	return mmConn
}

// Return sets up results that will be returned by FakeTx.Conn
func (mmConn *mFakeTxMockConn) Return(cp1 *pgx.Conn) *FakeTxMock {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("FakeTxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &FakeTxMockConnExpectation{mock: mmConn.mock}
	}
	mmConn.defaultExpectation.results = &FakeTxMockConnResults{cp1}
	mmConn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConn.mock
}

// Set uses given function f to mock the FakeTx.Conn method
func (mmConn *mFakeTxMockConn) Set(f func() (cp1 *pgx.Conn)) *FakeTxMock {
	if mmConn.defaultExpectation != nil {
		mmConn.mock.t.Fatalf("Default expectation is already set for the FakeTx.Conn method")
	}

	if len(mmConn.expectations) > 0 {
		mmConn.mock.t.Fatalf("Some expectations are already set for the FakeTx.Conn method")
	}

	mmConn.mock.funcConn = f
	mmConn.mock.funcConnOrigin = minimock.CallerInfo(1)
	return mmConn.mock
}

// Times sets number of times FakeTx.Conn should be invoked
func (mmConn *mFakeTxMockConn) Times(n uint64) *mFakeTxMockConn {
	if n == 0 {
		mmConn.mock.t.Fatalf("Times of FakeTxMock.Conn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConn.expectedInvocations, n)
	mmConn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConn
}

func (mmConn *mFakeTxMockConn) invocationsDone() bool {
	if len(mmConn.expectations) == 0 && mmConn.defaultExpectation == nil && mmConn.mock.funcConn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConn.mock.afterConnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Conn implements mm_service.FakeTx
func (mmConn *FakeTxMock) Conn() (cp1 *pgx.Conn) {
	mm_atomic.AddUint64(&mmConn.beforeConnCounter, 1)
	defer mm_atomic.AddUint64(&mmConn.afterConnCounter, 1)

	mmConn.t.Helper()

	if mmConn.inspectFuncConn != nil {
		mmConn.inspectFuncConn()
	}

	if mmConn.ConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConn.ConnMock.defaultExpectation.Counter, 1)

		mm_results := mmConn.ConnMock.defaultExpectation.results
		if mm_results == nil {
			mmConn.t.Fatal("No results are set for the FakeTxMock.Conn")
		}
		return (*mm_results).cp1
	}
	if mmConn.funcConn != nil {
		return mmConn.funcConn()
	}
	mmConn.t.Fatalf("Unexpected call to FakeTxMock.Conn.")
	return
}

// ConnAfterCounter returns a count of finished FakeTxMock.Conn invocations
func (mmConn *FakeTxMock) ConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.afterConnCounter)
}

// ConnBeforeCounter returns a count of FakeTxMock.Conn invocations
func (mmConn *FakeTxMock) ConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.beforeConnCounter)
}

// MinimockConnDone returns true if the count of the Conn invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockConnDone() bool {
	if m.ConnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnMock.invocationsDone()
}

// MinimockConnInspect logs each unmet expectation
func (m *FakeTxMock) MinimockConnInspect() {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FakeTxMock.Conn")
		}
	}

	afterConnCounter := mm_atomic.LoadUint64(&m.afterConnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && afterConnCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Conn at\n%s", m.ConnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && afterConnCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Conn at\n%s", m.funcConnOrigin)
	}

	if !m.ConnMock.invocationsDone() && afterConnCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.Conn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConnMock.expectedInvocations), m.ConnMock.expectedInvocationsOrigin, afterConnCounter)
	}
}

type mFakeTxMockCopyFrom struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockCopyFromExpectation
	expectations       []*FakeTxMockCopyFromExpectation

	callArgs []*FakeTxMockCopyFromParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockCopyFromExpectation specifies expectation struct of the FakeTx.CopyFrom
type FakeTxMockCopyFromExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockCopyFromParams
	paramPtrs          *FakeTxMockCopyFromParamPtrs
	expectationOrigins FakeTxMockCopyFromExpectationOrigins
	results            *FakeTxMockCopyFromResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockCopyFromParams contains parameters of the FakeTx.CopyFrom
type FakeTxMockCopyFromParams struct {
	ctx         context.Context
	tableName   pgx.Identifier
	columnNames []string
	rowSrc      pgx.CopyFromSource
}

// FakeTxMockCopyFromParamPtrs contains pointers to parameters of the FakeTx.CopyFrom
type FakeTxMockCopyFromParamPtrs struct {
	ctx         *context.Context
	tableName   *pgx.Identifier
	columnNames *[]string
	rowSrc      *pgx.CopyFromSource
}

// FakeTxMockCopyFromResults contains results of the FakeTx.CopyFrom
type FakeTxMockCopyFromResults struct {
	i1  int64
	err error
}

// FakeTxMockCopyFromOrigins contains origins of expectations of the FakeTx.CopyFrom
type FakeTxMockCopyFromExpectationOrigins struct {
	origin            string
	originCtx         string
	originTableName   string
	originColumnNames string
	originRowSrc      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCopyFrom *mFakeTxMockCopyFrom) Optional() *mFakeTxMockCopyFrom {
	mmCopyFrom.optional = true
	return mmCopyFrom
}

// Expect sets up expected params for FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) Expect(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.paramPtrs != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by ExpectParams functions")
	}

	mmCopyFrom.defaultExpectation.params = &FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
	mmCopyFrom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCopyFrom.expectations {
		if minimock.Equal(e.params, mmCopyFrom.defaultExpectation.params) {
			mmCopyFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyFrom.defaultExpectation.params)
		}
	}

	return mmCopyFrom
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) ExpectCtxParam1(ctx context.Context) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &FakeTxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.ctx = &ctx
	mmCopyFrom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectTableNameParam2 sets up expected param tableName for FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) ExpectTableNameParam2(tableName pgx.Identifier) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &FakeTxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.tableName = &tableName
	mmCopyFrom.defaultExpectation.expectationOrigins.originTableName = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectColumnNamesParam3 sets up expected param columnNames for FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) ExpectColumnNamesParam3(columnNames []string) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &FakeTxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.columnNames = &columnNames
	mmCopyFrom.defaultExpectation.expectationOrigins.originColumnNames = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectRowSrcParam4 sets up expected param rowSrc for FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) ExpectRowSrcParam4(rowSrc pgx.CopyFromSource) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &FakeTxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.rowSrc = &rowSrc
	mmCopyFrom.defaultExpectation.expectationOrigins.originRowSrc = minimock.CallerInfo(1)

	return mmCopyFrom
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) Inspect(f func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource)) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.inspectFuncCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("Inspect function is already set for FakeTxMock.CopyFrom")
	}

	mmCopyFrom.mock.inspectFuncCopyFrom = f

	return mmCopyFrom
}

// Return sets up results that will be returned by FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) Return(i1 int64, err error) *FakeTxMock {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{mock: mmCopyFrom.mock}
	}
	mmCopyFrom.defaultExpectation.results = &FakeTxMockCopyFromResults{i1, err}
	mmCopyFrom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCopyFrom.mock
}

// Set uses given function f to mock the FakeTx.CopyFrom method
func (mmCopyFrom *mFakeTxMockCopyFrom) Set(f func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error)) *FakeTxMock {
	if mmCopyFrom.defaultExpectation != nil {
		mmCopyFrom.mock.t.Fatalf("Default expectation is already set for the FakeTx.CopyFrom method")
	}

	if len(mmCopyFrom.expectations) > 0 {
		mmCopyFrom.mock.t.Fatalf("Some expectations are already set for the FakeTx.CopyFrom method")
	}

	mmCopyFrom.mock.funcCopyFrom = f
	mmCopyFrom.mock.funcCopyFromOrigin = minimock.CallerInfo(1)
	return mmCopyFrom.mock
}

// When sets expectation for the FakeTx.CopyFrom which will trigger the result defined by the following
// Then helper
func (mmCopyFrom *mFakeTxMockCopyFrom) When(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) *FakeTxMockCopyFromExpectation {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	expectation := &FakeTxMockCopyFromExpectation{
		mock:               mmCopyFrom.mock,
		params:             &FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc},
		expectationOrigins: FakeTxMockCopyFromExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCopyFrom.expectations = append(mmCopyFrom.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.CopyFrom return parameters for the expectation previously defined by the When method
func (e *FakeTxMockCopyFromExpectation) Then(i1 int64, err error) *FakeTxMock {
	e.results = &FakeTxMockCopyFromResults{i1, err}
	return e.mock
}

// Times sets number of times FakeTx.CopyFrom should be invoked
func (mmCopyFrom *mFakeTxMockCopyFrom) Times(n uint64) *mFakeTxMockCopyFrom {
	if n == 0 {
		mmCopyFrom.mock.t.Fatalf("Times of FakeTxMock.CopyFrom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCopyFrom.expectedInvocations, n)
	mmCopyFrom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCopyFrom
}

func (mmCopyFrom *mFakeTxMockCopyFrom) invocationsDone() bool {
	if len(mmCopyFrom.expectations) == 0 && mmCopyFrom.defaultExpectation == nil && mmCopyFrom.mock.funcCopyFrom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCopyFrom.mock.afterCopyFromCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCopyFrom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CopyFrom implements mm_service.FakeTx
func (mmCopyFrom *FakeTxMock) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCopyFrom.beforeCopyFromCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyFrom.afterCopyFromCounter, 1)

	mmCopyFrom.t.Helper()

	if mmCopyFrom.inspectFuncCopyFrom != nil {
		mmCopyFrom.inspectFuncCopyFrom(ctx, tableName, columnNames, rowSrc)
	}

	mm_params := FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

	// Record call args
	mmCopyFrom.CopyFromMock.mutex.Lock()
	mmCopyFrom.CopyFromMock.callArgs = append(mmCopyFrom.CopyFromMock.callArgs, &mm_params)
	mmCopyFrom.CopyFromMock.mutex.Unlock()

	for _, e := range mmCopyFrom.CopyFromMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCopyFrom.CopyFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyFrom.CopyFromMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyFrom.CopyFromMock.defaultExpectation.params
		mm_want_ptrs := mmCopyFrom.CopyFromMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCopyFrom.t.Errorf("FakeTxMock.CopyFrom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tableName != nil && !minimock.Equal(*mm_want_ptrs.tableName, mm_got.tableName) {
				mmCopyFrom.t.Errorf("FakeTxMock.CopyFrom got unexpected parameter tableName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originTableName, *mm_want_ptrs.tableName, mm_got.tableName, minimock.Diff(*mm_want_ptrs.tableName, mm_got.tableName))
			}

			if mm_want_ptrs.columnNames != nil && !minimock.Equal(*mm_want_ptrs.columnNames, mm_got.columnNames) {
				mmCopyFrom.t.Errorf("FakeTxMock.CopyFrom got unexpected parameter columnNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originColumnNames, *mm_want_ptrs.columnNames, mm_got.columnNames, minimock.Diff(*mm_want_ptrs.columnNames, mm_got.columnNames))
			}

			if mm_want_ptrs.rowSrc != nil && !minimock.Equal(*mm_want_ptrs.rowSrc, mm_got.rowSrc) {
				mmCopyFrom.t.Errorf("FakeTxMock.CopyFrom got unexpected parameter rowSrc, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originRowSrc, *mm_want_ptrs.rowSrc, mm_got.rowSrc, minimock.Diff(*mm_want_ptrs.rowSrc, mm_got.rowSrc))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyFrom.t.Errorf("FakeTxMock.CopyFrom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyFrom.CopyFromMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyFrom.t.Fatal("No results are set for the FakeTxMock.CopyFrom")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCopyFrom.funcCopyFrom != nil {
		return mmCopyFrom.funcCopyFrom(ctx, tableName, columnNames, rowSrc)
	}
	mmCopyFrom.t.Fatalf("Unexpected call to FakeTxMock.CopyFrom. %v %v %v %v", ctx, tableName, columnNames, rowSrc)
	return
}

// CopyFromAfterCounter returns a count of finished FakeTxMock.CopyFrom invocations
func (mmCopyFrom *FakeTxMock) CopyFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.afterCopyFromCounter)
}

// CopyFromBeforeCounter returns a count of FakeTxMock.CopyFrom invocations
func (mmCopyFrom *FakeTxMock) CopyFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.beforeCopyFromCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.CopyFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyFrom *mFakeTxMockCopyFrom) Calls() []*FakeTxMockCopyFromParams {
	mmCopyFrom.mutex.RLock()

	argCopy := make([]*FakeTxMockCopyFromParams, len(mmCopyFrom.callArgs))
	copy(argCopy, mmCopyFrom.callArgs)

	mmCopyFrom.mutex.RUnlock()

	return argCopy
}

// MinimockCopyFromDone returns true if the count of the CopyFrom invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockCopyFromDone() bool {
	if m.CopyFromMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CopyFromMock.invocationsDone()
}

// MinimockCopyFromInspect logs each unmet expectation
func (m *FakeTxMock) MinimockCopyFromInspect() {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.CopyFrom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCopyFromCounter := mm_atomic.LoadUint64(&m.afterCopyFromCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && afterCopyFromCounter < 1 {
		if m.CopyFromMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.CopyFrom at\n%s", m.CopyFromMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.CopyFrom at\n%s with params: %#v", m.CopyFromMock.defaultExpectation.expectationOrigins.origin, *m.CopyFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && afterCopyFromCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.CopyFrom at\n%s", m.funcCopyFromOrigin)
	}

	if !m.CopyFromMock.invocationsDone() && afterCopyFromCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.CopyFrom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CopyFromMock.expectedInvocations), m.CopyFromMock.expectedInvocationsOrigin, afterCopyFromCounter)
	}
}

type mFakeTxMockExec struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockExecExpectation
	expectations       []*FakeTxMockExecExpectation

	callArgs []*FakeTxMockExecParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockExecExpectation specifies expectation struct of the FakeTx.Exec
type FakeTxMockExecExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockExecParams
	paramPtrs          *FakeTxMockExecParamPtrs
	expectationOrigins FakeTxMockExecExpectationOrigins
	results            *FakeTxMockExecResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockExecParams contains parameters of the FakeTx.Exec
type FakeTxMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []any
}

// FakeTxMockExecParamPtrs contains pointers to parameters of the FakeTx.Exec
type FakeTxMockExecParamPtrs struct {
	ctx       *context.Context
	sql       *string
	arguments *[]any
}

// FakeTxMockExecResults contains results of the FakeTx.Exec
type FakeTxMockExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// FakeTxMockExecOrigins contains origins of expectations of the FakeTx.Exec
type FakeTxMockExecExpectationOrigins struct {
	origin          string
	originCtx       string
	originSql       string
	originArguments string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExec *mFakeTxMockExec) Optional() *mFakeTxMockExec {
	mmExec.optional = true
	return mmExec
}

// Expect sets up expected params for FakeTx.Exec
func (mmExec *mFakeTxMockExec) Expect(ctx context.Context, sql string, arguments ...any) *mFakeTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &FakeTxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.paramPtrs != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by ExpectParams functions")
	}

	mmExec.defaultExpectation.params = &FakeTxMockExecParams{ctx, sql, arguments}
	mmExec.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.Exec
func (mmExec *mFakeTxMockExec) ExpectCtxParam1(ctx context.Context) *mFakeTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &FakeTxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &FakeTxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.ctx = &ctx
	mmExec.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExec
}

// ExpectSqlParam2 sets up expected param sql for FakeTx.Exec
func (mmExec *mFakeTxMockExec) ExpectSqlParam2(sql string) *mFakeTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &FakeTxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &FakeTxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.sql = &sql
	mmExec.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmExec
}

// ExpectArgumentsParam3 sets up expected param arguments for FakeTx.Exec
func (mmExec *mFakeTxMockExec) ExpectArgumentsParam3(arguments ...any) *mFakeTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &FakeTxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &FakeTxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.arguments = &arguments
	mmExec.defaultExpectation.expectationOrigins.originArguments = minimock.CallerInfo(1)

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Exec
func (mmExec *mFakeTxMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...any)) *mFakeTxMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by FakeTx.Exec
func (mmExec *mFakeTxMockExec) Return(commandTag pgconn.CommandTag, err error) *FakeTxMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &FakeTxMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &FakeTxMockExecResults{commandTag, err}
	mmExec.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// Set uses given function f to mock the FakeTx.Exec method
func (mmExec *mFakeTxMockExec) Set(f func(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error)) *FakeTxMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the FakeTx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the FakeTx.Exec method")
	}

	mmExec.mock.funcExec = f
	mmExec.mock.funcExecOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// When sets expectation for the FakeTx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mFakeTxMockExec) When(ctx context.Context, sql string, arguments ...any) *FakeTxMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	expectation := &FakeTxMockExecExpectation{
		mock:               mmExec.mock,
		params:             &FakeTxMockExecParams{ctx, sql, arguments},
		expectationOrigins: FakeTxMockExecExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Exec return parameters for the expectation previously defined by the When method
func (e *FakeTxMockExecExpectation) Then(commandTag pgconn.CommandTag, err error) *FakeTxMock {
	e.results = &FakeTxMockExecResults{commandTag, err}
	return e.mock
}

// Times sets number of times FakeTx.Exec should be invoked
func (mmExec *mFakeTxMockExec) Times(n uint64) *mFakeTxMockExec {
	if n == 0 {
		mmExec.mock.t.Fatalf("Times of FakeTxMock.Exec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExec.expectedInvocations, n)
	mmExec.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExec
}

func (mmExec *mFakeTxMockExec) invocationsDone() bool {
	if len(mmExec.expectations) == 0 && mmExec.defaultExpectation == nil && mmExec.mock.funcExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExec.mock.afterExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exec implements mm_service.FakeTx
func (mmExec *FakeTxMock) Exec(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	mmExec.t.Helper()

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := FakeTxMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_want_ptrs := mmExec.ExecMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockExecParams{ctx, sql, arguments}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExec.t.Errorf("FakeTxMock.Exec got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmExec.t.Errorf("FakeTxMock.Exec got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.arguments != nil && !minimock.Equal(*mm_want_ptrs.arguments, mm_got.arguments) {
				mmExec.t.Errorf("FakeTxMock.Exec got unexpected parameter arguments, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originArguments, *mm_want_ptrs.arguments, mm_got.arguments, minimock.Diff(*mm_want_ptrs.arguments, mm_got.arguments))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("FakeTxMock.Exec got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExec.ExecMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the FakeTxMock.Exec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to FakeTxMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished FakeTxMock.Exec invocations
func (mmExec *FakeTxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of FakeTxMock.Exec invocations
func (mmExec *FakeTxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mFakeTxMockExec) Calls() []*FakeTxMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*FakeTxMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockExecDone() bool {
	if m.ExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecMock.invocationsDone()
}

// MinimockExecInspect logs each unmet expectation
func (m *FakeTxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Exec at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecCounter := mm_atomic.LoadUint64(&m.afterExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && afterExecCounter < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.Exec at\n%s", m.ExecMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Exec at\n%s with params: %#v", m.ExecMock.defaultExpectation.expectationOrigins.origin, *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && afterExecCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Exec at\n%s", m.funcExecOrigin)
	}

	if !m.ExecMock.invocationsDone() && afterExecCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.Exec at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecMock.expectedInvocations), m.ExecMock.expectedInvocationsOrigin, afterExecCounter)
	}
}

type mFakeTxMockLargeObjects struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockLargeObjectsExpectation
	expectations       []*FakeTxMockLargeObjectsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockLargeObjectsExpectation specifies expectation struct of the FakeTx.LargeObjects
type FakeTxMockLargeObjectsExpectation struct {
	mock *FakeTxMock

	results      *FakeTxMockLargeObjectsResults
	returnOrigin string
	Counter      uint64
}

// FakeTxMockLargeObjectsResults contains results of the FakeTx.LargeObjects
type FakeTxMockLargeObjectsResults struct {
	l1 pgx.LargeObjects
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLargeObjects *mFakeTxMockLargeObjects) Optional() *mFakeTxMockLargeObjects {
	mmLargeObjects.optional = true
	return mmLargeObjects
}

// Expect sets up expected params for FakeTx.LargeObjects
func (mmLargeObjects *mFakeTxMockLargeObjects) Expect() *mFakeTxMockLargeObjects {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("FakeTxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &FakeTxMockLargeObjectsExpectation{}
	}

	return mmLargeObjects
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.LargeObjects
func (mmLargeObjects *mFakeTxMockLargeObjects) Inspect(f func()) *mFakeTxMockLargeObjects {
	if mmLargeObjects.mock.inspectFuncLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("Inspect function is already set for FakeTxMock.LargeObjects")
	}

	mmLargeObjects.mock.inspectFuncLargeObjects = f

	return mmLargeObjects
}

// Return sets up results that will be returned by FakeTx.LargeObjects
func (mmLargeObjects *mFakeTxMockLargeObjects) Return(l1 pgx.LargeObjects) *FakeTxMock {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("FakeTxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &FakeTxMockLargeObjectsExpectation{mock: mmLargeObjects.mock}
	}
	mmLargeObjects.defaultExpectation.results = &FakeTxMockLargeObjectsResults{l1}
	mmLargeObjects.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLargeObjects.mock
}

// Set uses given function f to mock the FakeTx.LargeObjects method
func (mmLargeObjects *mFakeTxMockLargeObjects) Set(f func() (l1 pgx.LargeObjects)) *FakeTxMock {
	if mmLargeObjects.defaultExpectation != nil {
		mmLargeObjects.mock.t.Fatalf("Default expectation is already set for the FakeTx.LargeObjects method")
	}

	if len(mmLargeObjects.expectations) > 0 {
		mmLargeObjects.mock.t.Fatalf("Some expectations are already set for the FakeTx.LargeObjects method")
	}

	mmLargeObjects.mock.funcLargeObjects = f
	mmLargeObjects.mock.funcLargeObjectsOrigin = minimock.CallerInfo(1)
	return mmLargeObjects.mock
}

// Times sets number of times FakeTx.LargeObjects should be invoked
func (mmLargeObjects *mFakeTxMockLargeObjects) Times(n uint64) *mFakeTxMockLargeObjects {
	if n == 0 {
		mmLargeObjects.mock.t.Fatalf("Times of FakeTxMock.LargeObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLargeObjects.expectedInvocations, n)
	mmLargeObjects.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLargeObjects
}

func (mmLargeObjects *mFakeTxMockLargeObjects) invocationsDone() bool {
	if len(mmLargeObjects.expectations) == 0 && mmLargeObjects.defaultExpectation == nil && mmLargeObjects.mock.funcLargeObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLargeObjects.mock.afterLargeObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLargeObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LargeObjects implements mm_service.FakeTx
func (mmLargeObjects *FakeTxMock) LargeObjects() (l1 pgx.LargeObjects) {
	mm_atomic.AddUint64(&mmLargeObjects.beforeLargeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmLargeObjects.afterLargeObjectsCounter, 1)

	mmLargeObjects.t.Helper()

	if mmLargeObjects.inspectFuncLargeObjects != nil {
		mmLargeObjects.inspectFuncLargeObjects()
	}

	if mmLargeObjects.LargeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLargeObjects.LargeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmLargeObjects.LargeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmLargeObjects.t.Fatal("No results are set for the FakeTxMock.LargeObjects")
		}
		return (*mm_results).l1
	}
	if mmLargeObjects.funcLargeObjects != nil {
		return mmLargeObjects.funcLargeObjects()
	}
	mmLargeObjects.t.Fatalf("Unexpected call to FakeTxMock.LargeObjects.")
	return
}

// LargeObjectsAfterCounter returns a count of finished FakeTxMock.LargeObjects invocations
func (mmLargeObjects *FakeTxMock) LargeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.afterLargeObjectsCounter)
}

// LargeObjectsBeforeCounter returns a count of FakeTxMock.LargeObjects invocations
func (mmLargeObjects *FakeTxMock) LargeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.beforeLargeObjectsCounter)
}

// MinimockLargeObjectsDone returns true if the count of the LargeObjects invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockLargeObjectsDone() bool {
	if m.LargeObjectsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LargeObjectsMock.invocationsDone()
}

// MinimockLargeObjectsInspect logs each unmet expectation
func (m *FakeTxMock) MinimockLargeObjectsInspect() {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FakeTxMock.LargeObjects")
		}
	}

	afterLargeObjectsCounter := mm_atomic.LoadUint64(&m.afterLargeObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && afterLargeObjectsCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.LargeObjects at\n%s", m.LargeObjectsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && afterLargeObjectsCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.LargeObjects at\n%s", m.funcLargeObjectsOrigin)
	}

	if !m.LargeObjectsMock.invocationsDone() && afterLargeObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.LargeObjects at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LargeObjectsMock.expectedInvocations), m.LargeObjectsMock.expectedInvocationsOrigin, afterLargeObjectsCounter)
	}
}

type mFakeTxMockPrepare struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockPrepareExpectation
	expectations       []*FakeTxMockPrepareExpectation

	callArgs []*FakeTxMockPrepareParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockPrepareExpectation specifies expectation struct of the FakeTx.Prepare
type FakeTxMockPrepareExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockPrepareParams
	paramPtrs          *FakeTxMockPrepareParamPtrs
	expectationOrigins FakeTxMockPrepareExpectationOrigins
	results            *FakeTxMockPrepareResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockPrepareParams contains parameters of the FakeTx.Prepare
type FakeTxMockPrepareParams struct {
	ctx  context.Context
	name string
	sql  string
}

// FakeTxMockPrepareParamPtrs contains pointers to parameters of the FakeTx.Prepare
type FakeTxMockPrepareParamPtrs struct {
	ctx  *context.Context
	name *string
	sql  *string
}

// FakeTxMockPrepareResults contains results of the FakeTx.Prepare
type FakeTxMockPrepareResults struct {
	sp1 *pgconn.StatementDescription
	err error
}

// FakeTxMockPrepareOrigins contains origins of expectations of the FakeTx.Prepare
type FakeTxMockPrepareExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
	originSql  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrepare *mFakeTxMockPrepare) Optional() *mFakeTxMockPrepare {
	mmPrepare.optional = true
	return mmPrepare
}

// Expect sets up expected params for FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) Expect(ctx context.Context, name string, sql string) *mFakeTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &FakeTxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.paramPtrs != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by ExpectParams functions")
	}

	mmPrepare.defaultExpectation.params = &FakeTxMockPrepareParams{ctx, name, sql}
	mmPrepare.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) ExpectCtxParam1(ctx context.Context) *mFakeTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &FakeTxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &FakeTxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.ctx = &ctx
	mmPrepare.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPrepare
}

// ExpectNameParam2 sets up expected param name for FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) ExpectNameParam2(name string) *mFakeTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &FakeTxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &FakeTxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.name = &name
	mmPrepare.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmPrepare
}

// ExpectSqlParam3 sets up expected param sql for FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) ExpectSqlParam3(sql string) *mFakeTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &FakeTxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &FakeTxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.sql = &sql
	mmPrepare.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) Inspect(f func(ctx context.Context, name string, sql string)) *mFakeTxMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) Return(sp1 *pgconn.StatementDescription, err error) *FakeTxMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &FakeTxMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &FakeTxMockPrepareResults{sp1, err}
	mmPrepare.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrepare.mock
}

// Set uses given function f to mock the FakeTx.Prepare method
func (mmPrepare *mFakeTxMockPrepare) Set(f func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)) *FakeTxMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the FakeTx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the FakeTx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	mmPrepare.mock.funcPrepareOrigin = minimock.CallerInfo(1)
	return mmPrepare.mock
}

// When sets expectation for the FakeTx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mFakeTxMockPrepare) When(ctx context.Context, name string, sql string) *FakeTxMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	expectation := &FakeTxMockPrepareExpectation{
		mock:               mmPrepare.mock,
		params:             &FakeTxMockPrepareParams{ctx, name, sql},
		expectationOrigins: FakeTxMockPrepareExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Prepare return parameters for the expectation previously defined by the When method
func (e *FakeTxMockPrepareExpectation) Then(sp1 *pgconn.StatementDescription, err error) *FakeTxMock {
	e.results = &FakeTxMockPrepareResults{sp1, err}
	return e.mock
}

// Times sets number of times FakeTx.Prepare should be invoked
func (mmPrepare *mFakeTxMockPrepare) Times(n uint64) *mFakeTxMockPrepare {
	if n == 0 {
		mmPrepare.mock.t.Fatalf("Times of FakeTxMock.Prepare mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrepare.expectedInvocations, n)
	mmPrepare.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrepare
}

func (mmPrepare *mFakeTxMockPrepare) invocationsDone() bool {
	if len(mmPrepare.expectations) == 0 && mmPrepare.defaultExpectation == nil && mmPrepare.mock.funcPrepare == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrepare.mock.afterPrepareCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrepare.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Prepare implements mm_service.FakeTx
func (mmPrepare *FakeTxMock) Prepare(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	mmPrepare.t.Helper()

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, name, sql)
	}

	mm_params := FakeTxMockPrepareParams{ctx, name, sql}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, &mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_want_ptrs := mmPrepare.PrepareMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockPrepareParams{ctx, name, sql}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPrepare.t.Errorf("FakeTxMock.Prepare got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmPrepare.t.Errorf("FakeTxMock.Prepare got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmPrepare.t.Errorf("FakeTxMock.Prepare got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("FakeTxMock.Prepare got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the FakeTxMock.Prepare")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, name, sql)
	}
	mmPrepare.t.Fatalf("Unexpected call to FakeTxMock.Prepare. %v %v %v", ctx, name, sql)
	return
}

// PrepareAfterCounter returns a count of finished FakeTxMock.Prepare invocations
func (mmPrepare *FakeTxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of FakeTxMock.Prepare invocations
func (mmPrepare *FakeTxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mFakeTxMockPrepare) Calls() []*FakeTxMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*FakeTxMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockPrepareDone() bool {
	if m.PrepareMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrepareMock.invocationsDone()
}

// MinimockPrepareInspect logs each unmet expectation
func (m *FakeTxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Prepare at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrepareCounter := mm_atomic.LoadUint64(&m.afterPrepareCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && afterPrepareCounter < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.Prepare at\n%s", m.PrepareMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Prepare at\n%s with params: %#v", m.PrepareMock.defaultExpectation.expectationOrigins.origin, *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && afterPrepareCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Prepare at\n%s", m.funcPrepareOrigin)
	}

	if !m.PrepareMock.invocationsDone() && afterPrepareCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.Prepare at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrepareMock.expectedInvocations), m.PrepareMock.expectedInvocationsOrigin, afterPrepareCounter)
	}
}

type mFakeTxMockQuery struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockQueryExpectation
	expectations       []*FakeTxMockQueryExpectation

	callArgs []*FakeTxMockQueryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockQueryExpectation specifies expectation struct of the FakeTx.Query
type FakeTxMockQueryExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockQueryParams
	paramPtrs          *FakeTxMockQueryParamPtrs
	expectationOrigins FakeTxMockQueryExpectationOrigins
	results            *FakeTxMockQueryResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockQueryParams contains parameters of the FakeTx.Query
type FakeTxMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []any
}

// FakeTxMockQueryParamPtrs contains pointers to parameters of the FakeTx.Query
type FakeTxMockQueryParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]any
}

// FakeTxMockQueryResults contains results of the FakeTx.Query
type FakeTxMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// FakeTxMockQueryOrigins contains origins of expectations of the FakeTx.Query
type FakeTxMockQueryExpectationOrigins struct {
	origin     string
	originCtx  string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuery *mFakeTxMockQuery) Optional() *mFakeTxMockQuery {
	mmQuery.optional = true
	return mmQuery
}

// Expect sets up expected params for FakeTx.Query
func (mmQuery *mFakeTxMockQuery) Expect(ctx context.Context, sql string, args ...any) *mFakeTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &FakeTxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.paramPtrs != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by ExpectParams functions")
	}

	mmQuery.defaultExpectation.params = &FakeTxMockQueryParams{ctx, sql, args}
	mmQuery.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.Query
func (mmQuery *mFakeTxMockQuery) ExpectCtxParam1(ctx context.Context) *mFakeTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &FakeTxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &FakeTxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.ctx = &ctx
	mmQuery.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectSqlParam2 sets up expected param sql for FakeTx.Query
func (mmQuery *mFakeTxMockQuery) ExpectSqlParam2(sql string) *mFakeTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &FakeTxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &FakeTxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.sql = &sql
	mmQuery.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectArgsParam3 sets up expected param args for FakeTx.Query
func (mmQuery *mFakeTxMockQuery) ExpectArgsParam3(args ...any) *mFakeTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &FakeTxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &FakeTxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.args = &args
	mmQuery.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Query
func (mmQuery *mFakeTxMockQuery) Inspect(f func(ctx context.Context, sql string, args ...any)) *mFakeTxMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by FakeTx.Query
func (mmQuery *mFakeTxMockQuery) Return(r1 pgx.Rows, err error) *FakeTxMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &FakeTxMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &FakeTxMockQueryResults{r1, err}
	mmQuery.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// Set uses given function f to mock the FakeTx.Query method
func (mmQuery *mFakeTxMockQuery) Set(f func(ctx context.Context, sql string, args ...any) (r1 pgx.Rows, err error)) *FakeTxMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the FakeTx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the FakeTx.Query method")
	}

	mmQuery.mock.funcQuery = f
	mmQuery.mock.funcQueryOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// When sets expectation for the FakeTx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mFakeTxMockQuery) When(ctx context.Context, sql string, args ...any) *FakeTxMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	expectation := &FakeTxMockQueryExpectation{
		mock:               mmQuery.mock,
		params:             &FakeTxMockQueryParams{ctx, sql, args},
		expectationOrigins: FakeTxMockQueryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Query return parameters for the expectation previously defined by the When method
func (e *FakeTxMockQueryExpectation) Then(r1 pgx.Rows, err error) *FakeTxMock {
	e.results = &FakeTxMockQueryResults{r1, err}
	return e.mock
}

// Times sets number of times FakeTx.Query should be invoked
func (mmQuery *mFakeTxMockQuery) Times(n uint64) *mFakeTxMockQuery {
	if n == 0 {
		mmQuery.mock.t.Fatalf("Times of FakeTxMock.Query mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuery.expectedInvocations, n)
	mmQuery.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQuery
}

func (mmQuery *mFakeTxMockQuery) invocationsDone() bool {
	if len(mmQuery.expectations) == 0 && mmQuery.defaultExpectation == nil && mmQuery.mock.funcQuery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuery.mock.afterQueryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Query implements mm_service.FakeTx
func (mmQuery *FakeTxMock) Query(ctx context.Context, sql string, args ...any) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	mmQuery.t.Helper()

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := FakeTxMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_want_ptrs := mmQuery.QueryMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockQueryParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuery.t.Errorf("FakeTxMock.Query got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQuery.t.Errorf("FakeTxMock.Query got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQuery.t.Errorf("FakeTxMock.Query got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("FakeTxMock.Query got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQuery.QueryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the FakeTxMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to FakeTxMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished FakeTxMock.Query invocations
func (mmQuery *FakeTxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of FakeTxMock.Query invocations
func (mmQuery *FakeTxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mFakeTxMockQuery) Calls() []*FakeTxMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*FakeTxMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockQueryDone() bool {
	if m.QueryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryMock.invocationsDone()
}

// MinimockQueryInspect logs each unmet expectation
func (m *FakeTxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Query at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryCounter := mm_atomic.LoadUint64(&m.afterQueryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && afterQueryCounter < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.Query at\n%s", m.QueryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Query at\n%s with params: %#v", m.QueryMock.defaultExpectation.expectationOrigins.origin, *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && afterQueryCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Query at\n%s", m.funcQueryOrigin)
	}

	if !m.QueryMock.invocationsDone() && afterQueryCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.Query at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryMock.expectedInvocations), m.QueryMock.expectedInvocationsOrigin, afterQueryCounter)
	}
}

type mFakeTxMockQueryRow struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockQueryRowExpectation
	expectations       []*FakeTxMockQueryRowExpectation

	callArgs []*FakeTxMockQueryRowParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockQueryRowExpectation specifies expectation struct of the FakeTx.QueryRow
type FakeTxMockQueryRowExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockQueryRowParams
	paramPtrs          *FakeTxMockQueryRowParamPtrs
	expectationOrigins FakeTxMockQueryRowExpectationOrigins
	results            *FakeTxMockQueryRowResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockQueryRowParams contains parameters of the FakeTx.QueryRow
type FakeTxMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []any
}

// FakeTxMockQueryRowParamPtrs contains pointers to parameters of the FakeTx.QueryRow
type FakeTxMockQueryRowParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]any
}

// FakeTxMockQueryRowResults contains results of the FakeTx.QueryRow
type FakeTxMockQueryRowResults struct {
	r1 pgx.Row
}

// FakeTxMockQueryRowOrigins contains origins of expectations of the FakeTx.QueryRow
type FakeTxMockQueryRowExpectationOrigins struct {
	origin     string
	originCtx  string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRow *mFakeTxMockQueryRow) Optional() *mFakeTxMockQueryRow {
	mmQueryRow.optional = true
	return mmQueryRow
}

// Expect sets up expected params for FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) Expect(ctx context.Context, sql string, args ...any) *mFakeTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &FakeTxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.paramPtrs != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by ExpectParams functions")
	}

	mmQueryRow.defaultExpectation.params = &FakeTxMockQueryRowParams{ctx, sql, args}
	mmQueryRow.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) ExpectCtxParam1(ctx context.Context) *mFakeTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &FakeTxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &FakeTxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryRow.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryRow
}

// ExpectSqlParam2 sets up expected param sql for FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) ExpectSqlParam2(sql string) *mFakeTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &FakeTxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &FakeTxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.sql = &sql
	mmQueryRow.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQueryRow
}

// ExpectArgsParam3 sets up expected param args for FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) ExpectArgsParam3(args ...any) *mFakeTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &FakeTxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &FakeTxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.args = &args
	mmQueryRow.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...any)) *mFakeTxMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for FakeTxMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) Return(r1 pgx.Row) *FakeTxMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &FakeTxMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &FakeTxMockQueryRowResults{r1}
	mmQueryRow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryRow.mock
}

// Set uses given function f to mock the FakeTx.QueryRow method
func (mmQueryRow *mFakeTxMockQueryRow) Set(f func(ctx context.Context, sql string, args ...any) (r1 pgx.Row)) *FakeTxMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the FakeTx.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the FakeTx.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	mmQueryRow.mock.funcQueryRowOrigin = minimock.CallerInfo(1)
	return mmQueryRow.mock
}

// When sets expectation for the FakeTx.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mFakeTxMockQueryRow) When(ctx context.Context, sql string, args ...any) *FakeTxMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	expectation := &FakeTxMockQueryRowExpectation{
		mock:               mmQueryRow.mock,
		params:             &FakeTxMockQueryRowParams{ctx, sql, args},
		expectationOrigins: FakeTxMockQueryRowExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.QueryRow return parameters for the expectation previously defined by the When method
func (e *FakeTxMockQueryRowExpectation) Then(r1 pgx.Row) *FakeTxMock {
	e.results = &FakeTxMockQueryRowResults{r1}
	return e.mock
}

// Times sets number of times FakeTx.QueryRow should be invoked
func (mmQueryRow *mFakeTxMockQueryRow) Times(n uint64) *mFakeTxMockQueryRow {
	if n == 0 {
		mmQueryRow.mock.t.Fatalf("Times of FakeTxMock.QueryRow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRow.expectedInvocations, n)
	mmQueryRow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryRow
}

func (mmQueryRow *mFakeTxMockQueryRow) invocationsDone() bool {
	if len(mmQueryRow.expectations) == 0 && mmQueryRow.defaultExpectation == nil && mmQueryRow.mock.funcQueryRow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRow.mock.afterQueryRowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRow implements mm_service.FakeTx
func (mmQueryRow *FakeTxMock) QueryRow(ctx context.Context, sql string, args ...any) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	mmQueryRow.t.Helper()

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := FakeTxMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, &mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRow.QueryRowMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockQueryRowParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRow.t.Errorf("FakeTxMock.QueryRow got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQueryRow.t.Errorf("FakeTxMock.QueryRow got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRow.t.Errorf("FakeTxMock.QueryRow got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("FakeTxMock.QueryRow got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the FakeTxMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to FakeTxMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished FakeTxMock.QueryRow invocations
func (mmQueryRow *FakeTxMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of FakeTxMock.QueryRow invocations
func (mmQueryRow *FakeTxMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mFakeTxMockQueryRow) Calls() []*FakeTxMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*FakeTxMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockQueryRowDone() bool {
	if m.QueryRowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowMock.invocationsDone()
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *FakeTxMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.QueryRow at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryRowCounter := mm_atomic.LoadUint64(&m.afterQueryRowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && afterQueryRowCounter < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.QueryRow at\n%s", m.QueryRowMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.QueryRow at\n%s with params: %#v", m.QueryRowMock.defaultExpectation.expectationOrigins.origin, *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && afterQueryRowCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.QueryRow at\n%s", m.funcQueryRowOrigin)
	}

	if !m.QueryRowMock.invocationsDone() && afterQueryRowCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.QueryRow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowMock.expectedInvocations), m.QueryRowMock.expectedInvocationsOrigin, afterQueryRowCounter)
	}
}

type mFakeTxMockRollback struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockRollbackExpectation
	expectations       []*FakeTxMockRollbackExpectation

	callArgs []*FakeTxMockRollbackParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockRollbackExpectation specifies expectation struct of the FakeTx.Rollback
type FakeTxMockRollbackExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockRollbackParams
	paramPtrs          *FakeTxMockRollbackParamPtrs
	expectationOrigins FakeTxMockRollbackExpectationOrigins
	results            *FakeTxMockRollbackResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockRollbackParams contains parameters of the FakeTx.Rollback
type FakeTxMockRollbackParams struct {
	ctx context.Context
}

// FakeTxMockRollbackParamPtrs contains pointers to parameters of the FakeTx.Rollback
type FakeTxMockRollbackParamPtrs struct {
	ctx *context.Context
}

// FakeTxMockRollbackResults contains results of the FakeTx.Rollback
type FakeTxMockRollbackResults struct {
	err error
}

// FakeTxMockRollbackOrigins contains origins of expectations of the FakeTx.Rollback
type FakeTxMockRollbackExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollback *mFakeTxMockRollback) Optional() *mFakeTxMockRollback {
	mmRollback.optional = true
	return mmRollback
}

// Expect sets up expected params for FakeTx.Rollback
func (mmRollback *mFakeTxMockRollback) Expect(ctx context.Context) *mFakeTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &FakeTxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.paramPtrs != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by ExpectParams functions")
	}

	mmRollback.defaultExpectation.params = &FakeTxMockRollbackParams{ctx}
	mmRollback.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRollback.expectations {
		if minimock.Equal(e.params, mmRollback.defaultExpectation.params) {
			mmRollback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollback.defaultExpectation.params)
		}
	}

	return mmRollback
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.Rollback
func (mmRollback *mFakeTxMockRollback) ExpectCtxParam1(ctx context.Context) *mFakeTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &FakeTxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.params != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Expect")
	}

	if mmRollback.defaultExpectation.paramPtrs == nil {
		mmRollback.defaultExpectation.paramPtrs = &FakeTxMockRollbackParamPtrs{}
	}
	mmRollback.defaultExpectation.paramPtrs.ctx = &ctx
	mmRollback.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Rollback
func (mmRollback *mFakeTxMockRollback) Inspect(f func(ctx context.Context)) *mFakeTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by FakeTx.Rollback
func (mmRollback *mFakeTxMockRollback) Return(err error) *FakeTxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &FakeTxMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &FakeTxMockRollbackResults{err}
	mmRollback.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// Set uses given function f to mock the FakeTx.Rollback method
func (mmRollback *mFakeTxMockRollback) Set(f func(ctx context.Context) (err error)) *FakeTxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the FakeTx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the FakeTx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	mmRollback.mock.funcRollbackOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// When sets expectation for the FakeTx.Rollback which will trigger the result defined by the following
// Then helper
func (mmRollback *mFakeTxMockRollback) When(ctx context.Context) *FakeTxMockRollbackExpectation {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Set")
	}

	expectation := &FakeTxMockRollbackExpectation{
		mock:               mmRollback.mock,
		params:             &FakeTxMockRollbackParams{ctx},
		expectationOrigins: FakeTxMockRollbackExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRollback.expectations = append(mmRollback.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Rollback return parameters for the expectation previously defined by the When method
func (e *FakeTxMockRollbackExpectation) Then(err error) *FakeTxMock {
	e.results = &FakeTxMockRollbackResults{err}
	return e.mock
}

// Times sets number of times FakeTx.Rollback should be invoked
func (mmRollback *mFakeTxMockRollback) Times(n uint64) *mFakeTxMockRollback {
	if n == 0 {
		mmRollback.mock.t.Fatalf("Times of FakeTxMock.Rollback mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollback.expectedInvocations, n)
	mmRollback.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRollback
}

func (mmRollback *mFakeTxMockRollback) invocationsDone() bool {
	if len(mmRollback.expectations) == 0 && mmRollback.defaultExpectation == nil && mmRollback.mock.funcRollback == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollback.mock.afterRollbackCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollback.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Rollback implements mm_service.FakeTx
func (mmRollback *FakeTxMock) Rollback(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	mmRollback.t.Helper()

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback(ctx)
	}

	mm_params := FakeTxMockRollbackParams{ctx}

	// Record call args
	mmRollback.RollbackMock.mutex.Lock()
	mmRollback.RollbackMock.callArgs = append(mmRollback.RollbackMock.callArgs, &mm_params)
	mmRollback.RollbackMock.mutex.Unlock()

	for _, e := range mmRollback.RollbackMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRollback.RollbackMock.defaultExpectation.params
		mm_want_ptrs := mmRollback.RollbackMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockRollbackParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRollback.t.Errorf("FakeTxMock.Rollback got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollback.RollbackMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollback.t.Errorf("FakeTxMock.Rollback got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRollback.RollbackMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the FakeTxMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback(ctx)
	}
	mmRollback.t.Fatalf("Unexpected call to FakeTxMock.Rollback. %v", ctx)
	return
}

// RollbackAfterCounter returns a count of finished FakeTxMock.Rollback invocations
func (mmRollback *FakeTxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of FakeTxMock.Rollback invocations
func (mmRollback *FakeTxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Rollback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollback *mFakeTxMockRollback) Calls() []*FakeTxMockRollbackParams {
	mmRollback.mutex.RLock()

	argCopy := make([]*FakeTxMockRollbackParams, len(mmRollback.callArgs))
	copy(argCopy, mmRollback.callArgs)

	mmRollback.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockRollbackDone() bool {
	if m.RollbackMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackMock.invocationsDone()
}

// MinimockRollbackInspect logs each unmet expectation
func (m *FakeTxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Rollback at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRollbackCounter := mm_atomic.LoadUint64(&m.afterRollbackCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && afterRollbackCounter < 1 {
		if m.RollbackMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.Rollback at\n%s", m.RollbackMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Rollback at\n%s with params: %#v", m.RollbackMock.defaultExpectation.expectationOrigins.origin, *m.RollbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && afterRollbackCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.Rollback at\n%s", m.funcRollbackOrigin)
	}

	if !m.RollbackMock.invocationsDone() && afterRollbackCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.Rollback at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackMock.expectedInvocations), m.RollbackMock.expectedInvocationsOrigin, afterRollbackCounter)
	}
}

type mFakeTxMockSendBatch struct {
	optional           bool
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockSendBatchExpectation
	expectations       []*FakeTxMockSendBatchExpectation

	callArgs []*FakeTxMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FakeTxMockSendBatchExpectation specifies expectation struct of the FakeTx.SendBatch
type FakeTxMockSendBatchExpectation struct {
	mock               *FakeTxMock
	params             *FakeTxMockSendBatchParams
	paramPtrs          *FakeTxMockSendBatchParamPtrs
	expectationOrigins FakeTxMockSendBatchExpectationOrigins
	results            *FakeTxMockSendBatchResults
	returnOrigin       string
	Counter            uint64
}

// FakeTxMockSendBatchParams contains parameters of the FakeTx.SendBatch
type FakeTxMockSendBatchParams struct {
	ctx context.Context
	b   *pgx.Batch
}

// FakeTxMockSendBatchParamPtrs contains pointers to parameters of the FakeTx.SendBatch
type FakeTxMockSendBatchParamPtrs struct {
	ctx *context.Context
	b   **pgx.Batch
}

// FakeTxMockSendBatchResults contains results of the FakeTx.SendBatch
type FakeTxMockSendBatchResults struct {
	b1 pgx.BatchResults
}

// FakeTxMockSendBatchOrigins contains origins of expectations of the FakeTx.SendBatch
type FakeTxMockSendBatchExpectationOrigins struct {
	origin    string
	originCtx string
	originB   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mFakeTxMockSendBatch) Optional() *mFakeTxMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) Expect(ctx context.Context, b *pgx.Batch) *mFakeTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &FakeTxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &FakeTxMockSendBatchParams{ctx, b}
	mmSendBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectCtxParam1 sets up expected param ctx for FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) ExpectCtxParam1(ctx context.Context) *mFakeTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &FakeTxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &FakeTxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendBatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendBatch
}

// ExpectBParam2 sets up expected param b for FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) ExpectBParam2(b *pgx.Batch) *mFakeTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &FakeTxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &FakeTxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.b = &b
	mmSendBatch.defaultExpectation.expectationOrigins.originB = minimock.CallerInfo(1)

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) Inspect(f func(ctx context.Context, b *pgx.Batch)) *mFakeTxMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for FakeTxMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) Return(b1 pgx.BatchResults) *FakeTxMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &FakeTxMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &FakeTxMockSendBatchResults{b1}
	mmSendBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// Set uses given function f to mock the FakeTx.SendBatch method
func (mmSendBatch *mFakeTxMockSendBatch) Set(f func(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults)) *FakeTxMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the FakeTx.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the FakeTx.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	mmSendBatch.mock.funcSendBatchOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// When sets expectation for the FakeTx.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mFakeTxMockSendBatch) When(ctx context.Context, b *pgx.Batch) *FakeTxMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	expectation := &FakeTxMockSendBatchExpectation{
		mock:               mmSendBatch.mock,
		params:             &FakeTxMockSendBatchParams{ctx, b},
		expectationOrigins: FakeTxMockSendBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.SendBatch return parameters for the expectation previously defined by the When method
func (e *FakeTxMockSendBatchExpectation) Then(b1 pgx.BatchResults) *FakeTxMock {
	e.results = &FakeTxMockSendBatchResults{b1}
	return e.mock
}

// Times sets number of times FakeTx.SendBatch should be invoked
func (mmSendBatch *mFakeTxMockSendBatch) Times(n uint64) *mFakeTxMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of FakeTxMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	mmSendBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendBatch
}

func (mmSendBatch *mFakeTxMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements mm_service.FakeTx
func (mmSendBatch *FakeTxMock) SendBatch(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	mmSendBatch.t.Helper()

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ctx, b)
	}

	mm_params := FakeTxMockSendBatchParams{ctx, b}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := FakeTxMockSendBatchParams{ctx, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendBatch.t.Errorf("FakeTxMock.SendBatch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmSendBatch.t.Errorf("FakeTxMock.SendBatch got unexpected parameter b, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originB, *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("FakeTxMock.SendBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the FakeTxMock.SendBatch")
		}
		return (*mm_results).b1
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ctx, b)
	}
	mmSendBatch.t.Fatalf("Unexpected call to FakeTxMock.SendBatch. %v %v", ctx, b)
	return
}

// SendBatchAfterCounter returns a count of finished FakeTxMock.SendBatch invocations
func (mmSendBatch *FakeTxMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of FakeTxMock.SendBatch invocations
func (mmSendBatch *FakeTxMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mFakeTxMockSendBatch) Calls() []*FakeTxMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*FakeTxMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *FakeTxMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.SendBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FakeTxMock.SendBatch at\n%s", m.SendBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FakeTxMock.SendBatch at\n%s with params: %#v", m.SendBatchMock.defaultExpectation.expectationOrigins.origin, *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Errorf("Expected call to FakeTxMock.SendBatch at\n%s", m.funcSendBatchOrigin)
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to FakeTxMock.SendBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), m.SendBatchMock.expectedInvocationsOrigin, afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FakeTxMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockCommitInspect()

			m.MinimockConnInspect()

			m.MinimockCopyFromInspect()

			m.MinimockExecInspect()

			m.MinimockLargeObjectsInspect()

			m.MinimockPrepareInspect()

			m.MinimockQueryInspect()

			m.MinimockQueryRowInspect()

			m.MinimockRollbackInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FakeTxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FakeTxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCommitDone() &&
		m.MinimockConnDone() &&
		m.MinimockCopyFromDone() &&
		m.MinimockExecDone() &&
		m.MinimockLargeObjectsDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSendBatchDone()
}
